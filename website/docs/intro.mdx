---
sidebar_position: 1
---

import logo from './assets/logo-kivigo.png';


# KiviGo Documentation

<img style={{float: "left", width: "150px", marginRight: "1em"}} src={logo}></img>

Welcome to **KiviGo**, a lightweight, modular key-value store library for Go that provides a unified interface for different backends and encoders. 

The name is a play on words: "**Kivi**" sounds like "**key-value**" (the core concept of the library) and "**Go**" refers to the Go programming language. It also playfully evokes the fruit "**kiwi**" 🥝 !


## 🚀 What is KiviGo?

KiviGo is designed to simplify key-value storage operations in Go applications by providing:

- **Unified Interface**: Work with different storage backends using the same API
- **Modular Architecture**: Each backend is a separate Go module to minimize dependencies
- **Pluggable Encoders**: Support for JSON, YAML, and custom encoders
- **Zero-Boilerplate**: Automatic marshalling/unmarshalling of your Go structs
- **Testing-Friendly**: Built-in mock backend for unit testing

## ✨ Key Features

### 🔧 Multiple Backends

Choose from a variety of storage backends:

- **Embedded**: BadgerDB, BoltDB (local)
- **Distributed**: Redis, Consul, etcd
- **Cloud**: Azure Cosmos DB, DynamoDB
- **SQL**: MySQL, PostgreSQL
- **NoSQL**: MongoDB
- **In-Memory**: Memcached

### 📦 Modular Dependencies

Each backend is provided as a separate Go module. If you only need Redis, you only get Redis dependencies - keeping your application lightweight.

### 🎯 Simple API

```go
// Store any Go struct
type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
}

user := User{Name: "John", Email: "john@example.com"}
err := client.Set(ctx, "user:123", user)

// Retrieve it back
var retrievedUser User
err = client.Get(ctx, "user:123", &retrievedUser)
```

### 🧪 Testing Made Easy

Built-in mock backend for unit testing without external dependencies:

```go
mockKV := &mock.MockKV{Data: map[string][]byte{}}
client, _ := kivigo.New(mockKV)
// Test your code without Redis/Database
```

## 🎯 Use Cases

KiviGo is perfect for:

- **Configuration Management**: Store and retrieve application settings
- **Caching**: Implement distributed caching with Redis or local caching with BadgerDB
- **Session Storage**: Manage user sessions across different backends
- **Feature Flags**: Store and manage feature toggles
- **Distributed Coordination**: Use Consul or etcd for service discovery and coordination
- **Testing**: Write comprehensive unit tests with the mock backend

## 🏗️ Design Philosophy

### 1. Zero-Boilerplate Usage

No need to implement custom marshal/unmarshal methods. KiviGo automatically handles serialization using your chosen encoder.

### 2. Modular Go Packages

Each backend is a separate Go module. This approach allows you to:

- Fetch only the dependencies you need
- Keep your project lightweight
- Avoid version conflicts between different backend dependencies

### 3. Consistent Interface

Whether you're using Redis, BadgerDB, or any other backend, the API remains the same:

```go
client.Set(ctx, key, value)    // Store
client.Get(ctx, key, &value)   // Retrieve
client.Delete(ctx, key)        // Remove
client.List(ctx, prefix)       // List keys
```

## 🚀 Getting Started

Ready to start using KiviGo? Check out our [Getting Started Guide](./getting-started) to set up your first key-value store in minutes.

For backend-specific information, browse our [Backends](./backends/overview) section, or explore [Advanced Features](./advanced/health-checks) for more sophisticated use cases.

## 📝 License

KiviGo is released under the [Mozilla Public License 2.0](https://github.com/kivigo/kivigo/blob/main/LICENSE).
